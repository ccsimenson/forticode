"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityService = void 0;
const axios_1 = __importDefault(require("axios"));
class VulnerabilityService {
    constructor() {
        this.cache = new Map();
        this.cacheTimeout = 24 * 60 * 60 * 1000;
        // Clear expired cache entries when service is instantiated
        this.clearExpiredCacheEntries();
    }
    static getInstance() {
        if (!VulnerabilityService.instance) {
            VulnerabilityService.instance = new VulnerabilityService();
        }
        return VulnerabilityService.instance;
    }
    clearExpiredCacheEntries() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.timestamp > this.cacheTimeout) {
                this.cache.delete(key);
            }
        }
    }
    generateCpe(packageName, version) {
        // Format: cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*
        return `cpe:2.3:a:${packageName.toLowerCase().replace(/[^a-z0-9]/g, '_')}:${packageName.toLowerCase().replace(/[^a-z0-9]/g, '_')}:${version || '*'}:*:*:*:*:*:*:*`;
    }
    async getPackageVulnerabilities(packageName, version) {
        const cacheKey = `${packageName}:${version || 'latest'}`;
        const cachedEntry = this.cache.get(cacheKey);
        if (cachedEntry && Date.now() - cachedEntry.timestamp < this.cacheTimeout) {
            return cachedEntry.vulnerabilities;
        }
        try {
            const cpe = this.generateCpe(packageName, version);
            const vulnerabilities = await this.fetchVulnerabilities(cpe);
            const mappedVulnerabilities = vulnerabilities.map(vuln => this.mapNvdVulnerability(vuln));
            this.cache.set(cacheKey, {
                timestamp: Date.now(),
                vulnerabilities: mappedVulnerabilities
            });
            return mappedVulnerabilities;
        }
        catch (error) {
            console.error(`Error checking vulnerabilities for ${packageName}@${version}:`, error);
            throw error;
        }
    }
    async checkNodeVersionVulnerabilities(nodeVersion) {
        try {
            return await this.getPackageVulnerabilities('node', nodeVersion);
        }
        catch (error) {
            console.error('Error checking Node.js version vulnerabilities:', error);
            return [];
        }
    }
    async checkElectronVersionVulnerabilities(electronVersion) {
        try {
            return await this.getPackageVulnerabilities('electron', electronVersion);
        }
        catch (error) {
            console.error('Error checking Electron version vulnerabilities:', error);
            return [];
        }
    }
    async checkPackageDependenciesVulnerabilities(packageList) {
        const vulnerabilities = [];
        const checkDependency = async (packageName, version) => {
            try {
                const vulns = await this.getPackageVulnerabilities(packageName, version);
                vulnerabilities.push(...vulns);
            }
            catch (error) {
                console.error(`Error checking vulnerabilities for ${packageName}@${version}:`, error);
            }
        };
        await Promise.all(Object.entries(packageList).map(([name, version]) => checkDependency(name, version)));
        return vulnerabilities;
    }
    async fetchVulnerabilities(cpe) {
        try {
            const response = await axios_1.default.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${encodeURIComponent(cpe)}`);
            return response.data.vulnerabilities.map((vuln) => this.mapNvdVulnerability(vuln));
        }
        catch (error) {
            console.error(`Error fetching vulnerabilities for CPE ${cpe}:`, error);
            throw error;
        }
    }
    mapNvdVulnerability(vulnerability) {
        const cve = vulnerability.cve;
        const metrics = cve.metrics.cvssMetricV31[0];
        return {
            id: cve.id,
            name: cve.id,
            version: '',
            severity: metrics.cvssData.baseSeverity.toLowerCase(),
            description: cve.descriptions[0].value,
            references: cve.references.map((r) => r.url),
            published: cve.published,
            lastModified: cve.lastModified,
            cvssScore: metrics.cvssData.baseScore,
            vectorString: metrics.cvssData.vectorString,
            affectedVersions: []
        };
    }
}
exports.VulnerabilityService = VulnerabilityService;
//# sourceMappingURL=vulnerability-service.js.map