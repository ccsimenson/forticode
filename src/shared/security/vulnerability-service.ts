import { NvdVulnerability } from './types';
import axios from 'axios';

export class VulnerabilityService {
    private static instance: VulnerabilityService;
    private cache: Map<string, { vulnerabilities: NvdVulnerability[]; timestamp: number }> = new Map();
    private cacheTimeout = 24 * 60 * 60 * 1000;

    private constructor() {
        // Clear expired cache entries when service is instantiated
        this.clearExpiredCacheEntries();
    }

    static getInstance(): VulnerabilityService {
        if (!VulnerabilityService.instance) {
            VulnerabilityService.instance = new VulnerabilityService();
        }
        return VulnerabilityService.instance;
    }

    private clearExpiredCacheEntries() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.timestamp > this.cacheTimeout) {
                this.cache.delete(key);
            }
        }
    }

    private generateCpe(packageName: string, version?: string): string {
        // Format: cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*
        return `cpe:2.3:a:${packageName.toLowerCase().replace(/[^a-z0-9]/g, '_')}:${packageName.toLowerCase().replace(/[^a-z0-9]/g, '_')}:${version || '*'}:*:*:*:*:*:*:*`;
    }

    private async getPackageVulnerabilities(packageName: string, version?: string): Promise<NvdVulnerability[]> {
        const cacheKey = `${packageName}:${version || 'latest'}`;
        const cachedEntry = this.cache.get(cacheKey);
        
        if (cachedEntry && Date.now() - cachedEntry.timestamp < this.cacheTimeout) {
            return cachedEntry.vulnerabilities;
        }

        try {
            const cpe = this.generateCpe(packageName, version);
            const vulnerabilities = await this.fetchVulnerabilities(cpe);
            const mappedVulnerabilities = vulnerabilities.map(vuln => this.mapNvdVulnerability(vuln));

            this.cache.set(cacheKey, {
                timestamp: Date.now(),
                vulnerabilities: mappedVulnerabilities
            });

            return mappedVulnerabilities;
        } catch (error) {
            console.error(`Error checking vulnerabilities for ${packageName}@${version}:`, error);
            throw error;
        }
    }

    public async checkNodeVersionVulnerabilities(nodeVersion: string): Promise<NvdVulnerability[]> {
        try {
            return await this.getPackageVulnerabilities('node', nodeVersion);
        } catch (error) {
            console.error('Error checking Node.js version vulnerabilities:', error);
            return [];
        }
    }

    public async checkElectronVersionVulnerabilities(electronVersion: string): Promise<NvdVulnerability[]> {
        try {
            return await this.getPackageVulnerabilities('electron', electronVersion);
        } catch (error) {
            console.error('Error checking Electron version vulnerabilities:', error);
            return [];
        }
    }

    public async checkPackageDependenciesVulnerabilities(packageList: Record<string, string>): Promise<NvdVulnerability[]> {
        const vulnerabilities: NvdVulnerability[] = [];
        const checkDependency = async (packageName: string, version: string) => {
            try {
                const vulns = await this.getPackageVulnerabilities(packageName, version);
                vulnerabilities.push(...vulns);
            } catch (error) {
                console.error(`Error checking vulnerabilities for ${packageName}@${version}:`, error);
            }
        };

        await Promise.all(
            Object.entries(packageList).map(([name, version]) => checkDependency(name, version))
        );

        return vulnerabilities;
    }

    private async fetchVulnerabilities(cpe: string): Promise<NvdVulnerability[]> {
        try {
            const response = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${encodeURIComponent(cpe)}`);
            return response.data.vulnerabilities.map((vuln: any) => this.mapNvdVulnerability(vuln));
        } catch (error) {
            console.error(`Error fetching vulnerabilities for CPE ${cpe}:`, error);
            throw error;
        }
    }

    private mapNvdVulnerability(vulnerability: any): NvdVulnerability {
        const cve = vulnerability.cve;
        const metrics = cve.metrics.cvssMetricV31[0];
        return {
            id: cve.id,
            name: cve.id,
            version: '',
            severity: metrics.cvssData.baseSeverity.toLowerCase() as 'critical' | 'high' | 'medium' | 'low',
            description: cve.descriptions[0].value,
            references: cve.references.map((r: any) => r.url),
            published: cve.published,
            lastModified: cve.lastModified,
            cvssScore: metrics.cvssData.baseScore,
            vectorString: metrics.cvssData.vectorString,
            affectedVersions: []
        };
    }
}
