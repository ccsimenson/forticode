{"version":3,"file":"license-service.js","sourceRoot":"","sources":["license-service.ts"],"names":[],"mappings":"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","sourcesContent":["import { app } from 'electron';\nimport path from 'path';\nimport fs from 'fs-extra';\nimport crypto from 'crypto';\nimport { \n  LicenseKeyPayload, \n  LicenseValidationResult, \n  Feature,\n  FEATURES \n} from './types';\n\nconst LICENSE_FILE_NAME = 'license.json';\n// Public key would be defined here in production\n// const PUBLIC_KEY = `-----BEGIN PUBLIC KEY-----...`;\n\ninterface StoredLicense {\n  licenseKey: string;\n  signature: string;\n  machineId: string;\n  lastValidated: string;\n}\n\nexport class LicenseService {\n  private static instance: LicenseService;\n  private licenseData: StoredLicense | null = null;\n  private validationCache: Map<string, LicenseValidationResult> = new Map();\n  private readonly machineId: string;\n  private readonly licensePath: string;\n\n  private constructor() {\n    this.machineId = this.getMachineId();\n    this.licensePath = path.join(app.getPath('userData'), LICENSE_FILE_NAME);\n    this.loadLicense();\n  }\n\n  public static getInstance(): LicenseService {\n    if (!LicenseService.instance) {\n      LicenseService.instance = new LicenseService();\n    }\n    return LicenseService.instance;\n  }\n\n  private getMachineId(): string {\n    // Generate a machine-specific ID\n    const networkInterfaces = require('os').networkInterfaces();\n    let macAddress = '';\n    \n    // Get the first non-internal MAC address\n    for (const name of Object.keys(networkInterfaces)) {\n      for (const net of networkInterfaces[name]) {\n        if (!net.internal && net.mac && net.mac !== '00:00:00:00:00:00') {\n          macAddress = net.mac;\n          break;\n        }\n      }\n      if (macAddress) break;\n    }\n    \n    return crypto.createHash('sha256')\n      .update(macAddress + app.getPath('userData'), 'utf8')\n      .digest('hex');\n  }\n\n  private async loadLicense(): Promise<void> {\n    try {\n      if (await fs.pathExists(this.licensePath)) {\n        this.licenseData = await fs.readJson(this.licensePath);\n        // Validate the loaded license\n        await this.validateLicense();\n      }\n    } catch (error) {\n      console.error('Failed to load license:', error);\n      this.licenseData = null;\n    }\n  }\n\n  private async saveLicense(licenseKey: string, signature: string): Promise<void> {\n    this.licenseData = {\n      licenseKey,\n      signature,\n      machineId: this.machineId,\n      lastValidated: new Date().toISOString()\n    };\n    \n    await fs.ensureDir(path.dirname(this.licensePath));\n    await fs.writeJson(this.licensePath, this.licenseData, { spaces: 2 });\n  }\n\n  public async activateLicense(licenseKey: string): Promise<LicenseValidationResult> {\n    try {\n      // Remove any whitespace and normalize the key\n      licenseKey = licenseKey.trim().replace(/\\s+/g, '');\n      \n      // Basic format validation\n      if (!/^[A-Z0-9]{4}(?:-[A-Z0-9]{4}){3}$/i.test(licenseKey)) {\n        return { \n          isValid: false, \n          error: 'Invalid license key format. Expected format: XXXX-XXXX-XXXX-XXXX' \n        };\n      }\n\n      // In a real implementation, you would validate the license with your license server\n      // For this example, we'll simulate a successful validation\n      const validationResult = await this.validateWithServer(licenseKey);\n      \n      if (validationResult.isValid && validationResult.payload) {\n        // Sign the license payload with your private key (in a real app, this would be done on the server)\n        const signature = this.signPayload(validationResult.payload);\n        await this.saveLicense(licenseKey, signature);\n      }\n      \n      return validationResult;\n    } catch (error) {\n      console.error('License activation failed:', error);\n      return { \n        isValid: false, \n        error: error instanceof Error ? error.message : 'Unknown error during license activation' \n      };\n    }\n  }\n\n  public async deactivateLicense(): Promise<void> {\n    try {\n      if (await fs.pathExists(this.licensePath)) {\n        await fs.remove(this.licensePath);\n      }\n      this.licenseData = null;\n      this.validationCache.clear();\n    } catch (error) {\n      console.error('Failed to deactivate license:', error);\n      throw error;\n    }\n  }\n\n  public async validateLicense(): Promise<LicenseValidationResult> {\n    if (!this.licenseData) {\n      return { isValid: false, error: 'No license found' };\n    }\n\n    const cacheKey = `${this.licenseData.licenseKey}:${this.machineId}`;\n    \n    // Return cached validation if available and not expired (cache for 1 hour)\n    const cached = this.validationCache.get(cacheKey);\n    if (cached && \n        Date.now() - new Date(cached.payload?.issuedAt || 0).getTime() < 3600000) {\n      return cached;\n    }\n\n    try {\n      // Verify the signature\n      const isValidSignature = this.verifySignature(\n        this.licenseData.licenseKey,\n        this.licenseData.signature\n      );\n\n      if (!isValidSignature) {\n        return { isValid: false, error: 'Invalid license signature' };\n      }\n\n      // In a real app, you would validate with your license server here\n      const validationResult = await this.validateWithServer(this.licenseData.licenseKey);\n      \n      // Cache the validation result\n      if (validationResult.isValid) {\n        this.validationCache.set(cacheKey, validationResult);\n      }\n      \n      return validationResult;\n    } catch (error) {\n      console.error('License validation failed:', error);\n      return { \n        isValid: false, \n        error: error instanceof Error ? error.message : 'Unknown validation error' \n      };\n    }\n  }\n\n  private async validateWithServer(_licenseKey: string): Promise<LicenseValidationResult> {\n    // In a real implementation, this would make an API call to your license server\n    // For demonstration, we'll simulate a successful validation\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve({\n          isValid: true,\n          payload: {\n            features: [\n              Feature.ADVANCED_VULNERABILITY_SCANNING,\n              Feature.AUTOMATED_REPORTING\n            ],\n            customerId: 'demo-customer',\n            version: '1.0.0',\n            issuedAt: new Date().toISOString(),\n            expiryDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),\n            tier: 'pro' as const\n          }\n        });\n      }, 500);\n    });\n  }\n\n  private signPayload(payload: LicenseKeyPayload): string {\n    const sign = crypto.createSign('RSA-SHA256');\n    sign.update(JSON.stringify(payload));\n    // In a real implementation, use a proper private key\n    return sign.sign(\"your_private_key_here\", 'base64');\n  }\n\n  private verifySignature(_licenseKey: string, _signature: string): boolean {\n    try {\n      // In a real implementation, you would verify the signature with your public key\n      // This is a simplified version that always returns true for demonstration\n      return true;\n    } catch (error) {\n      console.error('Error verifying signature:', error);\n      return false;\n    }\n  }\n\n  private validateLicenseSync(): LicenseValidationResult {\n    if (!this.licenseData) {\n      return { isValid: false, error: 'No license found' };\n    }\n    \n    // Return a default valid result for demonstration\n    return {\n      isValid: true,\n      payload: {\n        features: [Feature.BASIC_CSP_VALIDATION],\n        customerId: 'demo-customer',\n        version: '1.0.0',\n        issuedAt: new Date().toISOString(),\n        expiryDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),\n        tier: 'pro' as const\n      }\n    };\n  }\n\n  public isFeatureEnabled(feature: Feature): boolean {\n    // Check if feature exists\n    const featureInfo = FEATURES[feature as keyof typeof FEATURES];\n    if (!featureInfo) {\n      console.warn(`Unknown feature: ${feature}`);\n      return false;\n    }\n\n    // Free features are always enabled\n    if (featureInfo.tier === 'free') {\n      return true;\n    }\n\n    // Check if we have a valid license\n    const validation = this.validateLicenseSync();\n    if (!validation.isValid || !validation.payload) {\n      return false;\n    }\n\n    const licenseTier = validation.payload.tier;\n    \n    // Check if the license tier is sufficient for this feature\n    if (licenseTier === 'enterprise') {\n      // Enterprise tier has access to all features\n      return true;\n    } else if (licenseTier === 'pro' && featureInfo.tier === 'pro') {\n      // Pro tier has access to pro and free features\n      return true;\n    }\n    \n    // Free tier only has access to free features (already handled above)\n    return false;\n  }\n\n  public async getLicenseInfo() {\n    if (!this.licenseData) {\n      return null;\n    }\n\n    const validation = await this.validateLicense();\n    if (!validation.isValid || !validation.payload) {\n      return null;\n    }\n\n    return {\n      licenseKey: this.licenseData.licenseKey,\n      customerId: validation.payload.customerId,\n      features: validation.payload.features,\n      expiryDate: validation.payload.expiryDate,\n      issuedAt: validation.payload.issuedAt,\n      lastValidated: this.licenseData.lastValidated\n    };\n  }\n\n  public async generateLicense(payload: Omit<LicenseKeyPayload, 'issuedAt'>): Promise<{ licenseKey: string; signature: string }> {\n    // Ensure tier is set\n    if (!payload.tier) {\n      // Default to free tier if not specified\n      payload.tier = 'free';\n    }\n\n    const completePayload: LicenseKeyPayload = {\n      ...payload,\n      issuedAt: new Date().toISOString(),\n      tier: payload.tier || 'free' // Ensure tier is always set\n    };\n\n    const licenseKey = Buffer.from(JSON.stringify(completePayload)).toString('base64');\n    const signature = this.signData(licenseKey);\n\n    return { licenseKey, signature };\n  }\n\n  public async generateTrialLicense(tier: 'pro' | 'enterprise' = 'pro' as const): Promise<{ licenseKey: string; signature: string }> {\n    // Define features based on tier\n    let trialFeatures: Feature[] = [];\n    \n    if (tier === 'pro') {\n      trialFeatures = [\n        // Pro tier features\n        Feature.ADVANCED_CSP_ANALYSIS,\n        Feature.AUTOMATED_FIX_SUGGESTIONS,\n        Feature.FULL_GITHUB_INTEGRATION,\n        Feature.COMPLIANCE_REPORTING,\n        // Include legacy features for backward compatibility\n        Feature.ADVANCED_VULNERABILITY_SCANNING,\n        Feature.AUTOMATED_REPORTING,\n        Feature.TEAM_COLLABORATION,\n        Feature.SCHEDULED_SCANS\n      ];\n    } else if (tier === 'enterprise') {\n      trialFeatures = [\n        // All features\n        ...Object.values(Feature).filter(f => \n          typeof f === 'string' && \n          f !== Feature.BASIC_SCANNING // Skip the legacy basic scanning feature\n        ) as Feature[]\n      ];\n    }\n\n    const expiryDate = new Date();\n    expiryDate.setDate(expiryDate.getDate() + 30); // 30-day trial\n\n    const payload: Omit<LicenseKeyPayload, 'issuedAt'> = {\n      features: trialFeatures,\n      customerId: `trial-${tier}-${Date.now()}`,\n      version: app.getVersion(),\n      expiryDate: expiryDate.toISOString(),\n      tier\n    };\n\n    return this.generateLicense(payload);\n  }\n\n  private signData(_data: string): string {\n    // In a real implementation, you would sign the data with a private key\n    // For demonstration purposes, we're just returning a hash\n    return crypto.createHash('sha256').update('demo').digest('hex');\n  }\n}\n\n// Export a singleton instance\nexport const licenseService = LicenseService.getInstance();\n"]}